io и applet

    Типы потоков ввода-вывода:
        В Java определяются два вида потоков ввода-вывода: байтовые и символьные.
            Байтовые потоки:
                1. Предоставляют средства для управления вводом и выводом отдельных байтов.
                2. Используются, например, при чтении и записи двоичных данных.
            Символьные потоки:
                1. Предоставляют средства для управления вводом и выводом отдельных символов.
                2. Используют кодировку в Unicode, что позволяет интернационализацию.
                3. Более эффективны, чем байтовые потоки для работы с символами.

    Основные классы потоков байтов:
        Потоки ввода-вывода байтов определены в двух иерархиях классов. Вершиной этих иерархий
            являются абстрактные классы InputStream и OutputStream.
    Ключевые методы в InputStream и OutputStream:
        Наиболее важными являются методы read() и write(), которые читают и записывают байты
            данных соответственно. Эти методы объявлены как абстрактные и переопределяются в
            производных классах.

    Основные классы потоков символов:
        Потоки ввода-вывода символов также определены в двух иерархиях классов, вершинами
            которых являются абстрактные классы Reader и Writer.

    Предопределенные потоки ввода-вывода:
        Все программы на Java автоматически импортируют пакет java.lang, в котором определен класс System;
        Класс System также содержит три предопределенные переменные потоков ввода-вывода: in, out и err;

        Переменные потоков
            System.out: Стандартный поток вывода, по умолчанию ссылается на консоль.
            System.in: Стандартный поток ввода, по умолчанию ссылается на клавиатуру.
            System.err: Стандартный поток вывода ошибок, по умолчанию также ссылается на консоль.

    Типы потоков
        System.in: Объект типа InputStream.
        System.out и System.err: Объекты типа PrintStream.


    Чтение данных с консоли:
        Конструкторы:
            1. BufferedReader(Reader поток_чтения_вводимых_данных)
            2. InputStreamReader(InputStream поток_ввода)

        Пример кода:
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
Заключение:
    Использование классов BufferedReader и InputStreamReader позволяет эффективно читать символы
        с консоли, что упрощает работу с вводом данных в современных приложениях.

Чтение символов и строк в Java:
    int read() throws IOException;

    Чтение строк:
    String readLine() throws IOException;

Запись данных и вывод на консоль:
    Вывод данных на консоль с помощью методов print() и println();

Чтение и запись данных в файлы:
    Открытие файла:
    FileInputStream(String имя_файла) throws FileNotFoundException
    FileOutputStream(String имя_файла) throws FileNotFoundException

Закрытие файла:
    void close() throws IOException

Чтение данных из файла:
    Метод read() из класса FileInputStream читает один байт из файла и возвращает его в виде
        целочисленного значения. При достижении конца файла возвращается значение -1.

Запись данных в файл:
    void write(int byteValue) throws IOException

Автоматическое закрытие файла:
    Оператор try с ресурсами:
       try (спецификация_ресурса) {
           // использование ресурса
       }




























Классы потоков ввода-вывода байтов:
    - абстрактные классы InputStream i OutputStream
    - Классы потоков ввода-вывода байтов из пакета java.io:

    BufferedInputStream - Буферизированный поток ввода;
    BufferedOutputStream - Буферизированный поток вывода;
    ByteArrayInputStream - Поток ввода, читающий байты из массива;
    ByteArrayOutputStream - Поток вывода, записывающий байты в массив;
    DataInputStream - Поток ввода, содержащий методы для чтения данных стандартных типов, определенных в java;
    DataOutputStream - Поток вывода, содержащий методы для записи данных стандартных типов, определенных в java;
    FileInputStream - Поток ввода, читающий данные из файла;
    FileOutputStream - Поток вывода, записывающий данные в файл;
    FilterInputStream - Реализует абстрактный класс InputStream;
    FilterOutputStream - Реализует абстрактный класс OutputStream;
    InputStream - Абстрактный класс, описывающий поток ввода;
    ObjectInputStream - Поток ввода объектов;
    ObjectOutputStream - Поток вывода объектов;
    OutputStream -  Абстрактный класс, описывающий поток вывода;
    PipedInputStream - Канал ввода;
    PipedOutputStream - Канал вывода;
    PrintStream - Поток вывода, содержащий методы print ( ) и println ( );
    PushbackInputStream - Поток ввода, поддерживающий возврат одного байта обратно в поток ввода;
    SequenceInputStream - Поток ввода, состоящий из двух и более потоков ввода, данные из которых читаются по очереди;

    - Классы потоков ввода-вывода символов из пакета java.io:
    BufferedReader - Буферизированный поток ввода символов;
    BufferedWriter - Буферизированный поток вывода символов;
    CharArrayReader - Поток ввода, читающий символы из массива;
    CharArrayWriter - Поток вывода, записывающий символы в массив;
    FileReader - Поток вывода, записывающий символы в массив Поток ввода, читающий символы из файла;
    FileWriter - Поток вывода, записывающий символы в файл;
    FilterReader - Фильтрованный поток чтения;
    FilterWriter - Фильтрованный поток записи;
    InputStreamReader - Поток ввода, преобразующий байты в символы;
    LineNumberReader - Поток ввода, подсчитывающий строки;
    OutputStreamWriter - Поток вывода, преобразующий символы в байты;
    PipedReader - Канал ввода;
    PipedWriter - Канал вывода;
    PrintWriter - Поток вывода,содержащий методы print() и println();
    PushbackReader - Поток ввода, позволяющий возвращать символы обратно в поток ввода;
    Reader - Абстрактный класс, описывающий поток ввода символов;
    StringReader - Поток ввода, читающий символы из строки;
    StringWriter - Поток вывода, записывающий символы в строку;
    Writer - Абстрактный класс, описывающий поток вывода символов;

    Предопределенные потоки ввода-вывода:
        - Переменная System.out ссылается на стандартный поток вывода;
        - Переменная System.in ссылается на стандартный поток ввода, которым по умолчанию является клавиатура;
        - А переменная System.err ссылается на стандартный поток вывода ошибок, которым по умолчанию также является консоль.

    Чтение и запись данных в файлы:


Автоматическое закрытие файла:
    - try (спецификация_ресурса){
    // использование ресурса
    }
        - спецификация_ресурса обозначает оператор, объявляющий и инициализирующий
        такой ресурс, как поток ввода-вывода в файл. Он состоит из объявления
        переменной , где переменная инициализируется ссьлкой на управляемый объект.
        - Оператор try с ресурсами применяется только с теми ресурсами,
        которые реализуют интерфейс AutoCloseable, определенный в пакете java.lang.
Доступ к списку подавленных исключений может быть получен с помощью метода getSuppressed(), определенного в классе Throwable.

Основы создания аплетов:
     - аплет - это небольшая прикладная программа, находящаяся на веб-сервере, откуда она загружается,
        автоматически устанавливается и запускается как составная часть веб-документа.
     import java.awt.*; - импортирует классы библиотеки Abstract Window Toolkit (АWТ).
     import java.applet.*; - импортирует пакет applet, в котором находится класс Applet.
        Каждый создаваемый апплет должен быть подклассом, прямо или косвенно производным от класса Applet.

     public class SimpleApplet extends Applet{
        public void paint(Graphics g) {
        g.drawString("Пpocтeйший апплет", 20, 20);
        }
     }

     - Метод paint() вызывается в том случае, когда апплет начинает свое выполнение.
        Независимо от конкретной причины, всякий раз, когда апплет должен перерисовать
        выводимый графическим способом результат, вызывается метод paint(), принимающий
        единственный параметр типа Graphics.

     - void drawString (String сообщение, int x, int y)
     -

Модификаторы доступа transient и volatile:
    - t r a n s i e n t , ее значение не должно сохраняться, когда сохраняется объект:
        class T{
        transient int a; // не сохранится
        int b; // сохранится
        }
    - Модификатор доступа volatile сообщает компилятору, что модифицируемая им переменная может
        быть неожиданно изменена в других частях программы.
        Пример:
        class MyClass{
        volatile int sharedVar;
        }
        Объявление переменной как volatile гарантирует, что все потоки будут использовать
            актуальное значение переменной из основной памяти.

Применение оператора instanceof:
Оператор instanceof в Java используется для проверки, является ли объект экземпляром
определённого класса или интерфейса. Это чрезвычайно полезно в ситуациях, когда вам
нужно убедиться, что объект соответствует ожидаемому типу перед выполнением операций,
которые могут быть невозможны или вызвать ошибку при неправильном типе объекта.
    Общая форма оператора:
        object instanceof type;

    - ссылка_на_объект instanceof тип;
        - ссылка_на_объект обозначает ссылку на экземпляр класса;
        - тип - конкретный тип этого класса;
    Применение:
    - Приведение типов: Перед тем как привести объект к определённому типу, можно проверить,
        поддерживает ли он этот тип, чтобы избежать исключения ClassCastException.
    - Проверка перед выполнением методов: Если у разных классов есть методы с одинаковыми
        именами, но различной реализацией, instanceof может помочь определить правильный тип
        объекта перед вызовом этих методов.
    - Реализация логики на основе типа: В программе может быть необходимо выполнить различные
        действия в зависимости от типа объекта.

    Ограничения:
    - Приводит к жёсткой связанности кода;
    - Нарушение принципов ООП;

Модификатор доступа strictfp:
    - Модификатор доступа strictfp в Java используется для обеспечения строгой точности в
        вычислениях с плавающей точкой.
    - Стандарт IEEE 754;
    - Основная цель использования strictfp — портируемость. Он обеспечивает, что вычисления с
        плавающей точкой будут давать одинаковый результат на всех платформах и всех JVM,
            независимо от архитектуры процессора или операционной системы.
    - Использование strictfp может слегка снизить производительность вычислений с плавающей точкой,
        потому что оно ограничивает оптимизации
    - Модификатор strictfp редко используется в обычной разработке программного обеспечения,
        но он может быть крайне важен в приложениях, где точность чисел с плавающей точкой имеет
        решающее значение.

Платформенно-ориентированные методы:
    - Платформенно-ориентированные методы в программировании относятся к методам или функциям,
которые напрямую зависят от операционной системы или аппаратной платформы, на которой
выполняется программа. Такие методы могут использоваться для выполнения задач, которые
требуют взаимодействия с особенностями конкретной платформы, например, для доступа к
системным вызовам, управления аппаратным обеспечением или оптимизации производительности
под специфические условия платформы.
    - Для объявления платформенно-ориентированных методов в java предусмотрено ключевое
        слово native;
    - Проблемы с платформенно-ориентированными методами:
        - Переносимость;
        - Сложность поддержки;
        - Безопасность;

Применение ключевого слова assert:
    - Оно используется на стадии разработки программ для создания так называемых утверждений - условий, которые должны быть истинными во время выполнения программы;
    - AssertionError;
    - Ключевое слово assert имеет две формы:
        - assert условие;
            - условие обозначает выражение, в результате вычисления которого должно быть получено логическое значение;
        - assert условие: выражение;
            - выражение обозначает значение, которое передается конструктору класса исключения AssertionError. Это значение преобразуется в строковую форму и выводится, если утверждение не подтверждается;
    - Советы по использованию assert:
        - для проверки условий, которые должны быть истинными, если ваш код работает корректно;
        - Не используйте утверждения для обработки условий пользовательского ввода или во внешних
        зависимостях, так как утверждения предназначены для отладки и могут быть отключены в
        производственной среде;
        - Утверждения могут быть полезны для проверки после вызова метода, что возвращаемое значение
        удовлетворяет определенному критерию, или что переменная находится в ожидаемом диапазоне
        значений.
Статический импорт:
    -




Вызов перегружаемых конструкторов по ссылке this ():
    - this (список_аргументов);

Общая форма обобщенного класса:
     - имя_класса<список_аргументов_типа> имя_переменой = new имя_класса<список_аргументов_типа> (список_аргументов_констант);

Ограниченные типы:
    -

Применение метасимвольных аргументов:
    -

Ограниченные метасимвопьные аргументы:
    - чтобы установить верхнюю границу для метасимвола:
    <? extends суперкласс>
    - указать нижнюю границу для метасимвольного аргумента:
    <? super подкласс>


Обобщенные интерфейсы:
    - class MyClass<T extends Comparable<T>> implememts MinMax<T>{}
    - class MyClass<T extends Comparable<T>> implemets MinMax<T extends Comparable>>{} //Неверно!
    - class MyClass implemets MinMax<T> {} // Неверно!
    - class MyClass implements MinMax<Integer> {} // Верно
    - Ниже приведена общая синтаксическая форма обобщенного интерфейса:
        - interface имя_интерфейса <с п и с о к_ п а р а м е т р о в _ т и п а> { // ..

Иерархии обобщенных классов:
// Простая иерархия обобщенных классов
class Gen<T> {
T ob;
Gen(T o){
ob = o;
}
//возвратить объект ob
T getob(){
return ob;
}
}

// Подкласс, производный от класса Gen
class Gen2<T> extends Gen<T> {
Gen2(T o){
super(o)
}
}
Сравнение типов в обобщенной иерархии во время выполнения:
     - instanceof -> используется для проверки, является ли объект экземпляром
     определенного класса или реализует ли он определенный интерфейс.
     Этот оператор возвращает значение true или false в зависимости от
     результата проверки.

Выведение типов и обобщения:
    - имя_класса <список_аргументов_типа> имя_переменной =
    new имя_класса<>(список_аргументов_конструктора)


























