1. Чем отличается ArrayList от LinkedList?
    -  ArrayList это список, реализованный на основе массива;
    - LinkedList — это классический связный список, основанный на объектах с ссылками между ними;
Основа реализации:
ArrayList: реализован на основе динамического массива.
LinkedList: реализован как двусвязный список, каждый элемент которого содержит ссылки на предыдущий и следующий элементы.
    Доступ к элементам:
    ArrayList: обеспечивает быстрый доступ к элементам по индексу (O(1)), благодаря чему чтение элементов происходит очень быстро.
    LinkedList: доступ к элементам осуществляется путём последовательного прохождения списка (O(n)), что делает произвольный доступ медленнее.

        Вставка и удаление элементов:
        ArrayList: вставка и удаление элементов, особенно в середине списка, требуют сдвига всех последующих элементов, что может быть ресурсозатратно (O(n)).
        LinkedList: вставка и удаление элементов происходит за константное время (O(1)), так как требуется лишь изменение ссылок у соседних элементов.

            Память:
            ArrayList: использует меньше памяти по сравнению с LinkedList, так как хранит только данные и индекс.
            LinkedList: каждый элемент хранит данные и две ссылки, что увеличивает потребление памяти.

                Производительность:
                ArrayList: лучше подходит для сценариев с частым доступом к элементам по индексу и когда изменения происходят преимущественно в конце списка.
                LinkedList: выгоден в случаях, когда необходимы частые вставка и удаление, особенно в середине списка.

                    Пример использования:
                    ArrayList: предпочтителен при реализации списков, где важен быстрый доступ к элементам.
                    LinkedList: лучше использовать для реализации очередей и других структур, где часто происходит добавление и удаление элементов.
2.  Что вы обычно используете (ArrayList или LinkedList)? Почему?
    - В 90% случае ArrayList будет быстрее и экономичнее LinkedList, так что
    обычно используют ArrayList, но тем не менее всегда есть 10% случаев для LinkedList.
3. Что быстрее работает ArrayList или LinkedList?
    - ArrayList: обеспечивает быстрый доступ к элементам по индексу (O(1)), благодаря чему чтение элементов происходит очень быстро.
         -  LinkedList: доступ к элементам осуществляется путём последовательного прохождения списка (O(n)), что делает произвольный доступ медленнее.
4. Необходимо добавить 1млн. элемент, какую структуру вы используете?
    - Нужно задавать дополнительные вопросы:
        - в какую часть списка происходит добавление элементов?
        - есть ли информация о том, что потом будет происходить с элементами списка?
        - какие то ограничения по памяти или скорости выполнения?
5. Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList?
    - Вставка и удаление элементов:
              ArrayList: вставка и удаление элементов, особенно в середине списка, требуют сдвига всех последующих элементов, что может быть ресурсозатратно (O(n)).
              LinkedList: вставка и удаление элементов происходит за константное время (O(1)), так как требуется лишь изменение ссылок у соседних элементов.
6. Предложите эффективный алгоритм удаления нескольких рядом стоящих элементов из середины списка, реализуемого ArrayList:
    - Один из наиболее эффективных подходов — это использование метода subList с последующим вызовом clear().
    Этот метод позволяет избежать многократного сдвига элементов, которое происходит при последовательном удалении элементов.
7. Как устроена HashMap?
    - Вкратце, HashMap состоит из «корзин» (bucket`ов). С технической точки зрения
        «корзины» — это элементы массива, которые хранят ссылки на списки элементов.
        При добавлении новой пары ключ-значение, вычисляет хеш-код ключа, на основании
        которого вычисляется номер корзины (номер ячейки массива), в которую попадет
        новый элемент. Если корзина пустая, то в нее сохраняется ссылка на вновь
        добавляемый элемент, если же там уже есть элемент, то происходит последовательный
        переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от
        которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден
        элемент с таким же ключом, то он заменяется. Добавление, поиск и удаление элементов
        выполняется за константное время. Вроде все здорово, с одной оговоркой, хеш-функций
        должна равномерно распределять элементы по корзинам, в этом случае временная
        сложность для этих 3 операций будет не ниже lg N, а в среднем случае как раз
        константное время.
8. Какое начальное количество корзин в HashMap?
    - По умолчанию начальное количество корзин в HashMap составляет 16.
9. Какая оценка временной сложности выборки элемента из HashMap? Гарантирует ли HashMap указанную сложность выборки элемента?
    - В идеальных условиях и при эффективном использовании хеш-функций, HashMap в Java предоставляет очень быстрый доступ к элементам по ключу за константное время O(1).
10. Роль equals и hashCode в HashMap?
    - hashCode позволяет определить корзину для поиска элемента, а equals
        используется для сравнения ключей элементов в списке внутри корзины и
        искомого ключа.
11. Максимальное число значений hashCode()?
    - достаточно вспомнить сигнатуру метода: int hashCode(). То есть число значений равно диапазону типа int — 2^32 (точного диапазона никогда не спрашивали, хватало такого ответа).
12. Как и когда происходит увеличение количества корзин в HashMap?
    - Помимо capacity в HashMap есть еще параметр loadFactor, на основании которого,
    вычисляется предельное количество занятых корзин (capacity*loadFactor).
    По умолчанию loadFactor = 0,75. По достижению предельного значения, число
    корзин увеличивается в 2 раза. Для всех хранимых элементов вычисляется новое
    «местоположение» с учетом нового числа корзин.
13. В каком случае может быть потерян элемент в HashMap?
    - Конкурентные модификации: Если несколько потоков одновременно модифицируют
    HashMap без должной синхронизации, может произойти потеря элементов. Например,
    если два потока пытаются вставить элементы в HashMap в одно и то же время,
    внутренняя структура данных может быть неправильно обновлена, в результате
    чего один из добавляемых элементов не будет добавлен. Это связано с тем, что
    операция перехеширования (расширение таблицы), которая автоматически выполняется
    при достижении порога загрузки, может быть нарушена конкурентными операциями.
14. Почему нельзя использовать byte[] в качестве ключа в HashMap?
    - хеш-код массива не зависит от хранимых в нем элементов, а присваивается при
    создании массива (метод вычисления хеш-кода массива не переопределен и вычисляется
    по стандартному Object.hashCode() на основании адреса массива). Так же у массивов
    не переопределен equals и выполняет сравнение указателей. Это приводит к тому,
    что обратиться к сохраненному с ключом-массивом элементу не получится при
    использовании другого массива такого же размера и с такими же элементами,
    доступ можно осуществить лишь в одном случае — при использовании той же самой
    ссылки на массив, что использовалась для сохранения элемента.
15. В чем отличия TreeSet и HashSet?
    - Set — это множество (так же называют «набором»). Set не допускает хранение
    двух одинаковых элементов. Формально говоря, термин «множество» и так обозначает
    совокупность различных элементов, очень важно, что именно различных элементов,
    так как это главное свойство Set.
    - TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева.
    Сложность выполнения основных операций в TreeSet lg N. HashSet использует для
    хранения элементов такой же подход, что и HashMap, за тем отличием, что в HashSet
    в качестве ключа выступает сам элемент, кроме того HashSet (как и HashMap)
    не поддерживает упорядоченное хранение элементов и обеспечивает временную
    сложность выполнения операций аналогично HashMap.
16. Устройство TreeSet?
    - TreeSet основан на красно-черном дереве.
17. Что будет, если добавлять элементы в TreeSet по возрастанию?
    - все элементы после доабвления в обычное бинарное дерево будут находится в
    одной ветви длиной N элементов, что сводит на нет, все преимущества такой
    структуры, как дерево (фактически получается список).








