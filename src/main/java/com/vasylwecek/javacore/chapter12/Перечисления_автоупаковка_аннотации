Перечисления
    - Перечисление (enum) — это набор констант
    - Метод values() возвращает все элементы перечисления, и вы можете использовать цикл for, чтобы их вывести или обработать.
    - Метод valueOf() позволяет извлечь элемент из перечисления, предоставляя его имя в виде строки.
    - Основные положения о перечислениях:
        - Перечисления создаются с помощью ключевого слова enum.
        enum Apple {
        Jonathan, GoldenDel, RedDel, Winesap, Cortland
        }
        - Jonathan, GoldenDel - называются константами перечислимого типа,
        -  В языке Java такие константы называются самотипизированными.
        - Apple ap;
        - Переменная ap относится к типу Apple.
        - ap = Apple.RedDel;
        - if (ap == Apple.GoldenDel) // ...
        - switch(ap){
        case Jonathan:
        // ...
        case RedDel:
        // ...
    - Методы values() и valueOf():
        - public static тип_перечисления [] values()
        - public static тип_перечисления valueOf(String строка)
         - Метод values() возвращает массив, содержащий список констант перечислимого типа.
         - А метод valueOf() возвращает константу перечислимого типа, значение которой соответствует символьной строке, переданной в качестве аргумента строка.
Однако на перечисления накладываются два ограничения:
    - Во-первых, перечисление не может наследоваться от другого класса.
    - И во-вторых, перечисление не может быть суперклассом.
        Это означает, что перечисление не может быть расширено.

Все перечисления автоматически наследуют от класса java.lang.Enum:
    - Вызвав метод ordinal(), можно получить значение, которое
        обозначает позицию константы в списке констант перечислимого типа.
        Это значение называется порядковым и извлекается из перечисления так, как показано: -> final nt ordinal().
    - С помощью метода compareTo() можно сравнить порядковые значения двух констант одного и того же перечислимого типа.
        Этот метод имеет следующую общую форму: final int compareTo(тип_перечисления e),
        где тип_перечисления обозначает тип конкретного перечисления, а е - константу, которую требуется сравнить с вызывающей константой.

        ordinal(): Возвращает порядковый номер элемента, начиная с нуля. Например, Jonathan имеет порядковый номер 0, GoldenDel — 1, и так далее.
        compareTo(): Сравнивает два элемента по порядковым номерам, возвращая отрицательное, положительное число или ноль.
        equals() и ==: Оба проверяют равенство, но == сравнивает ссылки на объект, а equals — содержание.

Оболочки типов:
    - К оболочкам типов относятся классы: Double, Float, Long, Integer, Short, Byte, Charcter, Boolean;

Класс Character:
     - Служит оболочкой для типа char.Конструктор Character() имеет следующую общую форму: Character(char символ);
     - Чтобы получить значение типа char, содержащееся в объекте типа Character, достаточно вызвать метод charValue(), как показано ниже. Этот метод возвращает инкапсулированный символ.
         char charValue().

Класс Boolean:
    - Служит оболочкой для логических значений типа boolean. В нем определены следующие конструкторы:
        - Boolean(boolean логическое_значение) = true или false;
        - Boolean(String логическая_строка)  = новый объект типа Boolean будет содержать логическое значение true, если логическая_строка содержит символьную строку "true"
            (в верхнем или нижнем регистре). В противном случае этот объект будет содержать логическое значение false.
            booleanValue().

Все оболочки числовых типов наследуют абстрактный класс NumЬer:
     - byte byteValue()
     - double doubleValue()
     - float floatValue()
     - int intValue()
     - long longValue()
     - short shortValue()

Приведены конструкторы, определенные в классе Integer.
    - Если строка не содержит числовое значение, то генерируется исключение типа NurnЬerFormatExceptionж
    - Integer ( int число)
    - Integer ( String строка)
В классах оболочек всех числовых типов переопределяется метод toString(). Он возвращает удобочитаемую форму значения,
    содержащегося в оболочке, что позволяет, например, выводить значение, передавая объект оболочки типа методу println()
    без дополнительного преобразования в примитивный тип.


Автоупаковка (Integer iOb = 100) - это процесс, в результате которого примитивный тип автоматически инкапсулируется (упаковывается) в эквивалентную ему оболочку типа всякий раз, когда требуется объект данного типа.
Автораспаковка (int i = iOb) - это процесс автоматического извлечения значения упакованного объекта (распаковки) из оболочки типа, когда нужно получить его значение.
     Благодаря этому отпадает необходимость вызывать методы вроде intValue () или doubleValue ().

Автоупаковка и методы:

Аннотации:
    Основы аннотирования программ:
    - языковое средство, позволяющее встраивать справочную информацию в исходные файлы;
    - Аннотации создаются с помощью механизма, основанного на интерфейсе;
    - // Простой тип аннотации:
        @interface MyAnno{
        String str();
        int val();
        }
    - Объявление аннотации не может включать в себя ключевое слово extends;
    - Все аннотации автоматически расширяют интерфейс Annotation:
        - Он объявлен в пакете java.lang.annotation.
        В интерфейсе Annotation переопределяются методы hashCode(), equals() и toString(),
        определенные в классе Object.
        - В нем также объявляется метод annotationType(), возвращающий объект типа Class,
        представляющий вызывающую аннотацию.
        - Аннотировать можно классы, методы, поля, параметры и константы перечислимого типа.
Правила удержания аннотаций:
    - В Java определены три такие правила, инкапсулированные в перечисление java.lang.annotation.RetentionPolicy:
        - SOURCE
        - CLASS
        - RUNTIME
Рефлексия - это языковое средство для получения сведений о классе во время выполнения программы.
java.lang.reflect
У метода getMethod ( ) имеется следующая общая форма:
Method getMethod(String имя_метода, Class<?> ... тип_параметра)

Получение всех аннотаций:
    - Для того чтобы получить сразу все аннотации, достаточно вызвать метод getAnnotations ();
    - Annotation[] getAnnotations()
    -  Метод getAnnotations ( ) возвращает массив аннотаций. Этот метод может быть вызван для объектов типа Class, Method, Constructor и Field.


Интepфeйc AnnotatedElement:
     - Методы getAnnotation() и getAnnotations определены в интерфейсе AnnotatedElement, который входит в состав пакета java.lang.reflect;
     - Метод getDeclaredAnnotations(): Annotation[] gerDeclaredAnnotations()
         - Данный метод возвращает ненаследуемые аннотации, присутствующие в вызывающем объекте.
     - Метод isAnnotationPresent(): boolean isAnnotationPresent(Class<? extends Annotation> тип_аннотации)
         - Этот метод возвращает логическое значение true, если аннотация, заданная в виде аргумента тип_аннотации, связана с вызывающим объектом.
Использование значений по умолчанию:
    - тип member() default значение;
    @Retention (RetentionPolicy.RUNTIME)
    @interface MyAnno{
        String str() default "Тестирование";
        int val() default 9000;
    }
    - четыре способа применения аннотации @MyAnno:
        @MyAnno()                          // значения str и val принимаются по умолчанию;
        @MyAnno (str = "Некоторая строка") // значение val - по умолчанию;
        @MyAnno(val = 100)                 //значение str - по умолчанию
        @MyAnno (str = "Тестирование", val = 100) //значения не по умолчанию

Ключевые моменты:

    - Аннотации: Позволяют добавлять метаданные к методам, классам и переменным.
    - Рефлексия: Используется для получения информации о программах во время выполнения.
    - Использование аннотаций: Аннотации могут быть использованы для настройки поведения методов.

Аннотации-маркеры:
    - Аннотация-маркер - это аннотация, которая не содержит никаких параметров и служит только для пометки метода, класса или поля.

Одночленные аннотации:
    - это специальный тип аннотаций, которые содержат всего один параметр;
    - В коде это означает, что если у аннотации только один параметр и
        он называется value, то при использовании этой аннотации можно
        не указывать имя параметра. Это упрощает запись и делает код
        более читабельным.

Встроенные аннотации:
    - java.lang.annotation: @Retention, @Deprecates, @FunctionalInterface, @SafeVarargs, @SuppressWarmings;
    - Аннотация @Retention:
        - Предназначена для применения только в качестве аннотации к другим аннотациям;
    - Аннотация @Documented:
        - Служит маркерным интерфейсом, сообщающим инструментальному средству разработки, что аннотация должна быть документирована;
    - Аннотация @Target:
        - Задает типы элементов, к которым можно применять аннотацию;
        - Она предназначена для применения только в качестве аннотации к другим аннотациям;
 Константы из перечисления ElementType:
    TYPE: Аннотация может быть применена к классу, интерфейсу (включая аннотационный интерфейс) или перечислению.
    FIELD: Аннотация может быть применена к полю класса (включает элементы перечисления).
    METHOD: Аннотация может быть применена к методу класса.
    PARAMETER: Аннотация может быть применена к параметру метода.
    CONSTRUCTOR: Аннотация может быть применена к конструктору.
    LOCAL_VARIABLE: Аннотация может быть применена к локальной переменной.
    ANNOTATION_TYPE: Аннотация может быть применена к другой аннотации.
    PACKAGE: Аннотация может быть применена к объявлению пакета.
    TYPE_PARAMETER (добавлен в Java 8): Аннотация может быть применена к параметру типа.
    TYPE_USE (добавлен в Java 8): Аннотация может быть применена к любому использованию типа.
    - Аннотация @ Inherited
    - Аннотация @Override
    - Аннотация @Dерrесаtеd
    - Aннoтaция @Functionalinterface
    - Аннотация @SafeVarargs
    - Aннoтaция @SuppressWarmings
Аннотации в Java обладают несколькими основными мета-аннотациями, которые определяют,
как и где аннотации могут быть использованы. Эти мета-аннотации включают:
@Target, @Retention, @Inherited, и @Documented. В каждой из этих
мета-аннотаций есть свои параметры, в том числе константы ElementType
для @Target и константы RetentionPolicy для @Retention.
Аннотации в Java обладают несколькими основными мета-аннотациями, которые определяют, как и где аннотации могут быть использованы. Эти мета-аннотации включают @Target, @Retention, @Inherited, и @Documented. В каждой из этих мета-аннотаций есть свои параметры, в том числе константы ElementType для @Target и константы RetentionPolicy для @Retention. Давайте рассмотрим подробнее каждую из этих мета-аннотаций и связанные с ними константы.

1. @Target
Мета-аннотация @Target определяет, где аннотацию можно использовать в вашем коде. Константы для @Target включают следующие значения из перечисления ElementType:

TYPE: Классы, интерфейсы (включая аннотационные интерфейсы), перечисления.
FIELD: Поля классов (включая константы enum).
METHOD: Методы.
PARAMETER: Параметры методов.
CONSTRUCTOR: Конструкторы.
LOCAL_VARIABLE: Локальные переменные.
ANNOTATION_TYPE: Аннотационные интерфейсы.
PACKAGE: Объявления пакетов.
TYPE_PARAMETER: Параметры типа (добавлены в Java 8).
TYPE_USE: Любое использование типа (добавлены в Java 8).
2. @Retention
Мета-аннотация @Retention указывает, как долго аннотации должны сохраняться. Константы для @Retention из перечисления RetentionPolicy включают:

SOURCE: Аннотации доступны только в исходном коде и не сохраняются в .class файле.
CLASS: Аннотации сохраняются в .class файле, но не доступны во время выполнения через reflection.
RUNTIME: Аннотации сохраняются в .class файле и доступны во время выполнения через reflection.
3. @Inherited
Мета-аннотация @Inherited указывает, что аннотация может быть наследована от суперкласса. Это значит, если вы пометите суперкласс аннотацией, которая определена с @Inherited, то подкласс автоматически будет считаться помеченным этой аннотацией.

4. @Documented
Мета-аннотация @Documented указывает, что аннотации с этой мета-аннотацией должны быть включены в Javadoc.

Аннотации и их целевые константы
    - @TypeAnno
        Целевые константы: ElementType.TYPE_USE
        Описание: Эта аннотация может быть использована в любом использовании типа. Это включает переменные, поля, параметры методов, объявления классов и интерфейсов, и т.д.
    - @MaxLen
        Целевые константы: ElementType.TYPE_USE
        Описание: Аналогично @TypeAnno, применяется для ограничения максимальной длины или размера, например, строк или коллекций.
    - @NotZeroLen
        Целевые константы: ElementType.TYPE_USE
        Описание: Используется для указания, что длина или размер значения должен быть не нулевым.
    - @Unique
        Целевые константы: ElementType.TYPE_USE
        Описание: Может использоваться для обозначения уникальности значения.
    - @What
        Целевые константы: ElementType.TYPE_PARAMETER
        Описание: Применяется к параметрам типа, что часто используется в обобщениях
        для указания дополнительной информации о параметре типа.
    - @EmptyOK
        Целевые константы: ElementType.FIELD
        Описание: Используется для обозначения того, что поле может иметь пустое значение или null.
    - @Recommended
        Целевые константы: ElementType.METHOD
        Описание: Может быть применена к методам для указания на рекомендуемый к использованию
        метод в библиотеке или фреймворке.
    - Контекст использования аннотаций
        Эти аннотации могут быть использованы для документирования кода, валидации или при
        использовании различных фреймворков и библиотек, которые поддерживают аннотации.
        Применение таких аннотаций улучшает читаемость кода, поддержку и обслуживание,
        а также может служить вспомогательным средством для генерации кода, документации
        или других аспектов автоматизации программной инженерии.