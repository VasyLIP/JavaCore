Приоритеты потоков

Синхронизация

Монитор - это механизм  управления, впервые определенный Чарльзом Энтони Ричардом Хоаром.
Как только  поток исполнения войдет в монитор, все другие потоки исполнения должны ожидать до тех пор, пока тот не покинет монитор.

Класс Thread и интерфейс Runnable:
    Многопоточная система в Java построена на основе класса Thread, его методах и дополняющем его интерфейсе Runnable.
    Класс Thread инкапсулирует поток исполнения.
    Чтобы создать новый поток исполнения, следует расширить класс Thread или же реализовать интерфейс Runnable.

    Методы управления потоками исполнения иэ класса Thread:
        getName     - Получает имя потока исполнения;
        getPriority - Получает приоритет потока исполнения;
        isAlive     - Определяет, выполняется ли поток;
        join        - Ожидает завершения потока исполнения;
        run         - Задает точку входа в поток исполнения;
        sleep       - Приостанавливает выполнение потока на заданное время;
        start       - Запускает поток исполнения, вызывая его метода run();
Общая форма sleep() метода выглядит следующим образом:
    static void sleep(long миллисекунд) throws InterruptedException

final void setName(String ...)
final String getName()

Создание потока исполнения:
    -> реализовав интерфейс Runnable:
        - Самый простой способ создать поток исполнения состоит в том, чтобы объявить класс,
        реализующий интерфейс Runnable. Этот интерфейс предоставляет абстракцию единицы исполняемого кода.
        - Для реализации интерфейса Runnable в классе должен быть объявлен единственный метод run():
            public void run();
        - После создания класса, реализующего интерфейс Runnable, в этом классе следует получить экземпляр объекта типа Thread.
        - Для этой цели в классе Thread определен ряд конструкторов: Thread(Runnable объект_потока, String имя_потока)
             -  объект_потока обозначает экземпляр класса, реализующего интерфейс Runnable;
             - имя нового потока исполнения передается данному конструктору в качестве параметра имя_потока.

    -> расширив класс Thread:
        - Еще один способ создать поток исполнения состоит в том, чтобы сначала объявить класс, расширяющий класс Thread,
        а затем получить экземпляр этого класса. В расширяющем классе должен быть непременно переопределен метод run (),
        который является точкой входа в новый поток исполнения. Кроме того, в этом классе должен быть вызван метод start()
        для запуска нового потока на исполнение.
Соэдание многих потоков исполнения:


Применение методов isAlive() и join():
     - нередко требуется, чтобы главный поток исполнения завершался последним.
     С этой целью метод sleep() вызывался в предыдущих примерах из метода main()
     с достаточной задержкой,чтобы все дочерние потоки исполнения завершились раньше главного.
     - Определить, был ли поток исполнения завершен, можно двумя способами:
        - метод isAlive(): final Boolean isAlive()
            - возвращает логическое значение true, если поток, для которого он вызван, еще исполняется.
        - метод join(): final void join() throws InterruptedException
            - метод ожидает завершения того потока исполнения, для которого он вызван.
                Его имя отражает следующий принцип: вызывающий поток ожидает, когда указанный поток присоединится к нему.

Приоритеты потоков исполнения:
    - Чтобы установить приоритет потока исполнения, следует вызвать метод setPriority() из класса Thread.
        Его общая форма выглядит следующим образом: final void setPriority(int уровень);
    - Для того чтобы получить текущее значение приоритета потока исполнения, достаточно
        вызвать метод getPriority ( ) из класса Thread, как показано ниже.
        final int getPriority ( );

Применение синхронизированных методов:
    - Чтобы войти в монитор объекта, достаточно вызвать метод, объявленный с модификатором доступа synchronized;


Оператор synchronized:
    - synchronized(ссылука_на_обькт){
        // синхронизируёМые операторы
        }


Взаимодействие потоков исполнения:
    - Эти методы реализованы как завершенные в классе Object, поэтому они доступны всем классам.
        - Метод wait() вынуждает вызывающий поток исполнения уступить монитор и перейти в состояние
            ожидания до тех пор, пока какой-нибудь другой поток исполнения не войдет в тот же монитор
            и не вызовет метод notify();
        -  Метод notify() возобновляет исполнение потока, из которого был вызван метод wait() для
            того же самого объекта.
        - Метод notifyAll() возобновляет исполнение всех потоков, из которых был вызван метод wait()
            для того же самого объекта. Одному из этих потоков предоставляется доступ.
        final void wait() throws InterruptedException;
        final void notify();
        final void notifyAll();


Значения, возвращаемые методом getState():
    - BLOCKED: Поток приостановил выполнение, поскольку ожидает получения блокировки;
    - NEW: Поток еще не начал выполнение
    - RUNNABLE: Поток в настоящее время выполняется или начнет выполняться, когда получит доступ к ЦП;
    - TERMINATED: Поток завершил выполнение;
    - TIMED_WAITING: Поток приостановил выполнение на определенный промежуток времени, например, после вызова метода sleep ( ) .
        Поток переходит в это состояние и при вызове метода wait ( ) или join ( );





